\chapter{The Foreign Function Interface}
\label{usage}

\epigraph{Since large programs grow from small ones, it is crucial that we develop an arsenal of\\ standard program structures of whose correctness we have become sure—we call them idioms—\\and learn to combine them into larger structures using organizational techniques of proven value.}{Alan J. Perlis~\cite{abelson1996structure}}


In this chapter, we will showcase a simple use case of CertiCoq's foreign function interface and examine the glue code generated by CertiCoq.

For pedagogical purposes, this chapter discusses implementing in C what one could have also implemented in Coq (though less efficiently), but later chapters describe foreign functions that could not be implemented in Coq.

The Coq code described in this chapter uses \gls{Vernacular} commands that are defined in the CertiCoq plugin, namely \kw{CertiCoq Register}, \kw{CertiCoq Compile}, and \kw{CertiCoq Generate Glue} commands. In order to be able to run these \gls{Vernacular} commands, you would have to have a CertiCoq installation on your machine or in your container.

\section{An Example Use of the Interface}
Suppose we want to have a hand-optimized implementation of a Coq function. Take the \fn{div2} function from the Coq standard library. This function divides a natural number by 2.

\begin{Verbatim}
\kw{Fixpoint} \fn{div2} (\bn{n} : \ty{nat}) :=
  \kw{match} \bn{n} \kw{with}
  | \dt{S} (\dt{S} \bn{n'}) => \dt{S} (\fn{div2} \bn{n'})
  | _ => \dt{0}
  \kw{end}.
\end{Verbatim}

Notice that \fn{div2} is not tail recursive, and it allocates memory for the constructor \dt{S} before every recursive call. Hence this function is not memory and stack-space efficient. It is possible to write a more efficient version of this function with tail recursion and no memory allocations:

\begin{Verbatim}
\kw{Definition} \fn{better_div2} (\bn{n} : \ty{nat}) : \ty{nat} :=
  \kw{let fix} \fn{aux} (\bn{n} \bn{m} : \ty{nat}) : \ty{nat} :=
    \kw{match} \bn{n} , \bn{m} \kw{with}
    | \dt{S} \bn{n'}, \dt{S} (\dt{S} \bn{m'}) => \fn{aux} \bn{n' m'}
    | \dt{S} \bn{n'}, \dt{1} => \bn{n'}
    | _, _ => \bn{n}
    \kw{end}
  \kw{in} \fn{aux} \bn{n n}.
\end{Verbatim}

To achieve optimal performance, CertiCoq compiles this function into a tail-recursive C function. This C function can then be further optimized into a loop by smart C compilers like CompCert, GCC, or Clang at higher optimization levels. In fact, both GCC and Clang can generate code that is comparable to hand-written C code for this function. 
% However, if we need to use CompCert or if we have to use lower optimization levels due to other reasons (e.g., if our unverified C compiler occasionally produces buggy output at higher optimization levels), we can take a different approach. We can declare the function as a foreign function in Coq and implement it in C.
However, we will show a different approach to compile more complex and compute-intensive functions, such as cryptographic primitives that could benefit from using C primitives such as arrays and bit-level arithmetic  \cite{appel2015sha256}. For simplicity, we will continue to use \fn{div2} as a pedagogical example.

To be able to call our function, we have to create an object on the Coq side. We follow Coq's traditional program extraction mechanism here and ask the user to declare the function as an axiom, which will be realized later when we compile our program.

\begin{Verbatim}
\kw{Axiom} \fn{best_div2} : \ty{nat} -> \ty{nat}.
\end{Verbatim}

Once we declare the axiom, we can tell the compiler that this axiom will be realized by a C function, and where that C function lives. This is achieved through the \kw{CertiCoq Register} command:

\begin{Verbatim}
\kw{CertiCoq} \kw{Register} [ \fn{best_div2} => \dt{"best_div2"} ] \kw{Include} [ \dt{"prims.h"} ].
\end{Verbatim}

Now we can declare our C function in a C header file:

\begin{Verbatim}
\ty{value} \fn{best_div2}(\ty{value});
\end{Verbatim}

CertiCoq represents Coq values in memory in a uniform way, as we will describe in greater detail in \autoref{memoryrepresentation}. We have the C type \ty{value} that all Coq values, regardless of their types, live in. In other words, \ty{value} is the C type of Coq values represented in C. The arguments and the result of our function, when realized in C, will all have the C type \ty{value}.

Finally, we can implement our function in a C source file:

\begin{Verbatim}
\ty{value} \fn{best_div2}(\ty{value} \bn{a}) \{
  \ty{value} \bn{tortoise} = \bn{a}, \bn{hare} = \bn{a};
  \cm{/* All these function calls will be inlined by the compiler, of course. */}
  \kw{while} (\fn{get_Coq_Init_Datatypes_nat_tag}(\bn{hare}) \fn{=}\fn{=} \dt{1}) \{
    \bn{tortoise} = \fn{get_args}(\bn{tortoise})[\dt{0}];
    \bn{hare} = \fn{get_args}(\bn{hare})[\dt{0}];
    \kw{if} (\fn{get_Coq_Init_Datatypes_nat_tag}(\bn{hare}) \fn{=}\fn{=} \dt{1}) \{
      \bn{hare} = \fn{get_args}(\bn{hare})[\dt{0}];
    \} \kw{else} \{
      \kw{break};
    \}
  \}
  \kw{return} \bn{tortoise};
\}
\end{Verbatim}

% Our C implementation takes in a Coq value represented in C and outputs a Coq value represented in C.
% Thankfully, a user of CertiCoq's foreign function interface does not have to understand fully how this representation works or what the \ty{value} type is internally; there are functions they can use to interact with \ty{value}s, such as the functions we use in the function above. We refer to these functions collectively as \emph{\gls{glue code}}. We will examine all the functions in glue code automatically generated by CertiCoq in detail in \autoref{glue}.

The C implementation of the function accepts a Coq value represented in C as input and returns a Coq value represented in C as output. Fortunately, users of CertiCoq's foreign function interface do not need to have a deep understanding of the internal workings of the \ty{value} type or how the representation works. CertiCoq provides a set of functions, collectively known as \emph{\gls{glue code}}, that users can use to interact with \ty{value}s, including the functions used in the above function. In the next section (\autoref{glue}), we will examine the details of all the functions automatically generated by CertiCoq in the glue code.

Now we can write a Coq program that uses \fn{best\_div2} and compile it.

\begin{Verbatim}
\kw{Definition} \fn{prog} : \ty{nat} := \fn{best_div2} \dt{5}.
\kw{CertiCoq} \kw{Compile} -file \dt{"prog"} \fn{prog}.
\kw{CertiCoq} \kw{Generate} \kw{Glue} -file \dt{"glue"} [ \ty{nat} ].
\end{Verbatim}

The \kw{CertiCoq Compile} command compiles a program to C but does not print or use the result. The generated program, by default, does not print or use the result either. This differs from other functional languages like Haskell or OCaml. Haskell programs have an effectful program entry point called \fn{main} with the type \ty{IO ()}, which is executed when the program runs. OCaml programs can feature function calls outside of definitions, which run when the program is run, allowing effectful function invocations or an effectful program entry point. CertiCoq programs do not have these, therefore we need to write a C wrapper file to use the result from the Coq code compiled by CertiCoq. This C file serves as the program entry point, one that cannot be written directly in Coq:

\begin{Verbatim}
\kw{#include} \dt{"gc_stack.h"}
\kw{#include} \dt{"glue.h"}
\kw{#include} \dt{"prog.h"}
\end{Verbatim}
\newpage{}

\begin{Verbatim}
\ty{int} \fn{main}() \{
  \kw{struct} \ty{thread_info *}\tinfo{} = \fn{make_tinfo}();
  \ty{value} \bn{result} = \fn{body}(\tinfo{});
  \fn{print_Coq_Init_Datatypes_nat}(\bn{result});
  \kw{return} \dt{0};
\}
\end{Verbatim}

Inside the \fn{main} function, we first create the initial thread information object. Then we call the \fn{body} function, which evaluates the compiled program, namely \fn{prog} in our Coq file. We get the result back and then call a glue code function to print the result. In our case, this program will print \code{(S (S O))}.

The thread information object is a \kw{struct} that contains the necessary information for the CertiCoq runtime to work. This includes the call stack, the location and bounds of the \gls{CertiCoq heap}, and the location of the next allocatable spot in that heap~\cite{belanger2019verified, belanger2019certified, paraskevopoulou2020verified}. We will refer to this object as the \emph{\gls{thread info}}, often abbreviated as \tinfo{} when used as a function argument or a local definition.

Any function that potentially allocates memory in the \gls{CertiCoq heap} must take the \gls{thread info} as an argument. Our foreign C function, \fn{best\_div2}, only inspects Coq values; it does not create new ones. However, if we were to write a version of it that does allocate memory, we would need to declare that to the CertiCoq compiler when registering the foreign function:

\begin{Verbatim}
\kw{CertiCoq} \kw{Register} [ \fn{best_div2} => \dt{"best_div2"} \kw{with tinfo} ] \kw{Include} [ \dt{"prims.h"} ].
\end{Verbatim}

Then the C function type of our foreign function could include the \gls{thread info} as well:

\begin{Verbatim}
\ty{value} \fn{best_div2}(\kw{struct} \ty{thread_info *}\tinfo{}, \ty{value});
\end{Verbatim}

Now that we have reviewed how CertiCoq's foreign function interface is used, let us take a closer look at the glue functions generated by CertiCoq, and how they are implemented.

\section{Generated Glue Code}\label{glue}

The \kw{CertiCoq Generate Glue} command takes a sequence of Coq \gls{inductive type}s and generates corresponding glue functions. For example, if a programmer intends to write foreign functions that interact with Coq \ty{list}s and \ty{nat}s, they would call this command:

\begin{Verbatim}
\kw{CertiCoq} \kw{Generate} \kw{Glue} [ \ty{list} , \ty{nat} ].
\end{Verbatim}

When this vernacular command is run, the compiler generates a file that contains functions in C that programmers can use when writing foreign functions. Here we will explain every kind of function generated in detail, in separate subsections. The functions we will see below will have some syntactic sugar that your compiler output may not have\footnote{This is because when CertiCoq generates C code, it produces Clight code, which is a syntactically restricted subset of C, and then prints it as C code.}, but they are the same functions otherwise.

Generated C functions that are specialized to a particular Coq type will use the fully qualified name of types. For a function that mentions the \ty{list} type by name, the function name will contain \ty{Coq.Init.Datatypes.list} (but with underscores instead of dots), so that name clashes are avoided.

\subsection{Constructing Coq Values}

VeriFFI automatically generates C functions that construct the values for each constructor in each Coq \gls{inductive type} requested by the user. For instance, for the \ty{list} type, VeriFFI generates these functions:\newpage

\newcommand{\makenil}{\hyperref[code:makenil]{\fn{make\_\linebreak[0]Coq\_\linebreak[0]Init\_\linebreak[0]Datatypes\_\linebreak[0]list\_\linebreak[0]nil}}}
\newcommand{\makecons}{\hyperref[code:makecons]{\fn{make\_\linebreak[0]Coq\_\linebreak[0]Init\_\linebreak[0]Datatypes\_\linebreak[0]list\_\linebreak[0]cons}}}
\newcommand{\allocmakecons}{\hyperref[code:allocmakecons]{\fn{alloc\_\linebreak[0]make\_\linebreak[0]Coq\_\linebreak[0]Init\_\linebreak[0]Datatypes\_\linebreak[0]list\_\linebreak[0]cons}}}
\begin{Verbatim}
\ty{value} \makenil{}\label{code:makenil}(\ty{void}) \{
  \kw{return} (\ty{value}) \dt{1};
\}

\ty{value} \makecons{}\label{code:makecons}(\ty{value} \bn{arg0}, \ty{value} \bn{arg1}, \ty{value *}\bn{argv}) \{
  \bn{argv}[\dt{0}] = (\ty{value}) \dt{2048};
  \bn{argv}[\dt{1}] = \bn{arg0};
  \bn{argv}[\dt{2}] = \bn{arg1};
  \kw{return} \bn{argv} \fn{+} \dt{1};
\}

\ty{value} \allocmakecons{}\label{code:allocmakecons}
      (\kw{struct} \ty{thread_info *}\tinfo{}, \ty{value} \bn{arg0}, \ty{value} \bn{arg1}) \{
  \ty{value *}\bn{argv} = \tinfo{}->\bn{alloc};
  \bn{argv}[\dt{0}] = (\ty{value}) \dt{2048};
  \bn{argv}[\dt{1}] = \bn{arg0};
  \bn{argv}[\dt{2}] = \bn{arg1};
  \tinfo{}->\bn{alloc} = \tinfo{}->\bn{alloc} \fn{+} \dt{3};
  \kw{return} \bn{argv} + \dt{1};
\}
\end{Verbatim}

The generated glue function for a constructor can look differently depending on whether it has \gls{boxed} or \gls{unboxed} representation. We provide a more detailed explanation of these representations in \autoref{memoryrepresentation}.
Unboxed constructors, like the \dt{nil} constructor, are represented as integers at runtime. This can be observed in the \makenil{} function.
On the other hand, boxed constructors such as the \dt{cons} constructor, are represented as pointers to memory locations that store the constructor arguments. This memory can exist either within the CertiCoq runtime's garbage-collected memory region, known as the \emph{\gls{CertiCoq heap}}, or outside of it in what we refer to as the \emph{C heap}.
For the \dt{cons} constructor, the \makecons{} function creates a value in the C heap, while the \allocmakecons{} function creates a value in the \gls{CertiCoq heap}.\newpage

When creating a value on the \gls{CertiCoq heap} with the \allocmakecons{} function, we have to pass the \gls{thread info} object so that the glue function knows where to allocate memory. 

When creating a value on the \gls{C heap} with the \makecons{} function, however, we need to pass a pointer to a part of memory, namely \bn{argv}, where the glue function can build a value.
The \bn{argv} pointer must have enough available memory for the function to write on. It requires one word for each \constructor{}, and a word right before the pointer to store header information. It is the programmer's responsibility to free this memory later or keep track of what can be freed and when. The CertiCoq garbage collector does not touch this allocated memory. When allocating on the \gls{C heap}, one must take care of pointers from there into the garbage-collected heap. The CertiCoq garbage collector has mechanisms to manage that, but to avoid such complexity, in this thesis work we have focused mostly on allocation in the \gls{CertiCoq heap}.

\subsection{Discriminating Coq Constructors}

For each Coq \gls{inductive type}, VeriFFI generates a separate C function that allows the user to determine the constructor used to create a value of that type. For example, for the \ty{list} type, the function would be:

\begin{Verbatim}
\ty{unsigned long long} \fn{get_Coq_Init_Datatypes_list_tag}(\ty{value} \bn{v}) \{
  \kw{if} (\fn{is_ptr}(\bn{v})) \{
    \kw{switch} (\fn{get_boxed_ordinal}(\bn{v})) \{
      \kw{case} \dt{0}:
        \kw{return} \dt{1};
    \}
  \} \kw{else} \{
    \kw{switch} (\fn{get_unboxed_ordinal}(\bn{v})) \{
      \kw{case} \dt{0}:
        \kw{return} \dt{0};
    \}
  \}
  \cm{/* In the future, we can add the unreachable() annotation here,}
     \cm{to improve the C compiler's ability to optimize this function. */}
\}
\end{Verbatim}

This function takes a Coq value and returns an integer that matches the word size of your machine, which we call the \emph{\gls{tag}} of the constructor.

A tag is an index (starting from \texttt{0}) denoting the order of the
constructor that was used to create the value at hand. When the C
representation of a Coq value is passed into this function, it returns
\texttt{0} for \dt{nil} and \texttt{1} for \dt{cons}. For
further ease of use, the programmer can define an \kw{enum} type:
\begin{Verbatim}
\kw{typedef} \kw{enum} \{\ \dt{NIL}, \dt{CONS} \}\ \ty{coq\_list};
\end{Verbatim}
The programmer can then treat the result of this function as a value of type \ty{coq\_list}. However, CertiCoq does not generate this type automatically.

Internally, each constructor has an \emph{\gls{ordinal}}, the index of a constructor within the constructors of that \gls{inductive type} with the same \gls{boxity}. Counting the \gls{boxed} and \gls{unboxed} constructors separately is a trick that allows representing a larger number of constructors in the \ty{value} type. However, it is important to note that ordinals are specific to the compiler's implementation and it is not recommended for FFI users to depend on them while writing C code. Instead, it is advisable to use \gls{tag}s and glue functions.

\subsection{Extracting Arguments of a Coq Constructor} 

Given a Coq value of an \gls{inductive type}, we would like to be able to access its \constructor{} arguments. We have a single C function that works on values of any \gls{inductive type}, as long as the value is \gls{boxed}:

\begin{Verbatim}
\ty{value *}\fn{get_args}(\ty{value} \bn{v}) \{
  \kw{return} (\ty{value *}) \bn{v};
\}
\end{Verbatim}

Calling the \fn{get\_args} function on \gls{unboxed} values, \gls{closure}s, or type values will cause undefined behavior at runtime.

\subsection{Printing Coq Values}

For each Coq \gls{inductive type} requested by the user, VeriFFI provides a C function that prints values of that type.
For instance, for the \ty{list} type, this would be:

\begin{Verbatim}
\ty{void} \fn{print_Coq_Init_Datatypes_list}(\ty{value} \bn{v}, \ty{void} \fn{print_param_A}(\ty{value}))
\{
  \ty{unsigned int} \bn{tag};
  \ty{void *}\bn{args};
  \bn{tag} = \fn{get_Coq_Init_Datatypes_list_tag}(\bn{v});
  \kw{switch} (\bn{tag}) \{
    \kw{case} \dt{0}:
      \fn{printf}(\fn{names_of_Coq_Init_Datatypes_list}[\bn{tag}]);
      \kw{break};
    \kw{case} \dt{1}:
      \bn{args} = \fn{get_args}(\bn{v});
      \fn{printf}(\fn{lparen_lit});
      \fn{printf}(\fn{names_of_Coq_Init_Datatypes_list}[\bn{tag}]);
      \fn{printf}(\fn{space_lit});
      \fn{print_param_A}(\fn{get_args}(\bn{args})[\dt{0}]);
      \fn{printf}(\fn{space_lit});
      \fn{print_Coq_Init_Datatypes_list}(\fn{get_args}(\bn{args})[\dt{1}], \fn{print_param_A});
      \fn{printf}(\fn{rparen_lit});
      \kw{break};
  \}
\}
\end{Verbatim}

Notice how since \ty{list} is a parameterized type, the printing function takes a function pointer to deal with values of the parameter type.

\subsection{Calling Coq Closures}

The CertiCoq compiler represents Coq functions as \gls{closure}s at runtime, which consist of a function and an environment, but are not directly callable in C. To call these from C, one must fetch the code-pointer, fetch the environment pointer, and pass the environment as one of the arguments to the code-pointer function.  We have a C function that implements this protocol:

\begin{Verbatim}
\ty{value} \fn{call}(\kw{struct} \ty{thread_info *}\tinfo{}, \ty{value} \bn{clo}, \ty{value} \bn{arg}) \{
  \ty{value} \bn{f} = ((\kw{struct} \ty{closure *}) \bn{clo})->\fn{func};
  \ty{value} \bn{envi} = ((\kw{struct} \ty{closure *}) \bn{clo})->\fn{env};
  \kw{return} ((\ty{value} (\ty{*})(\kw{struct} \ty{thread_info *}, \ty{value}, \ty{value})) \bn{f}) (\tinfo{}, \bn{envi}, \bn{arg});
\}
\end{Verbatim}

When compiling a function definition with CertiCoq, programmers can use the \fn{call} function to pass arguments to it. The \fn{call} function also requires the \gls{thread info} as an argument because functions within \gls{closure}s need the \gls{thread info} to perform memory allocation.
